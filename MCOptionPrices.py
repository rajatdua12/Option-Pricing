#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Oct  1 16:18:30 2019

@author: rajatdua
"""
"""
In this problem, MCOptionPrices.py, I have defined a function MCOptionPrices, with 
following inputs: S0, K, T, rateCurve, sigma, t, checkpoints, samples, and integrator. 
The output of the function is a dictionary with 4 key value pairs, that is, an array of 
running means at each checkpoint with a key ‘Means’; an array of running standard deviations 
at each checkpoint with key ‘StdDevs’; an array of running standard error at each checkpoint 
with key ‘StdErrs’; and a floating point variable that represents the final value or the mean 
at the last checkpoint, represented by key ‘TVs’.  I have plotted graphs for each of the methods 
to compare the convergence properties of standard error with increase in number samples or 
sample paths(M).
"""

import numpy as np
import scipy.stats as st
norminv = st.distributions.norm.ppf
norm = st.distributions.norm.cdf
import numpy.linalg
from numpy import exp,sqrt,maximum,mean,std,log,cumsum
from numpy.random import randn,rand
import pandas as pd
import matplotlib.pyplot as plt

def MCOptionPrices(S0, K, T, rateCurve, sigma, t, checkpoints, samples, integrator):
    
    """
       't' is an array of 
fixing times ti; i = 1....N to simulate to.
       'K' is the strike price.
       'T' is the expiration date of the European option.
       'rateCurve' is an InterestRateCurve stored as a numpy array.
       'checkpoints' is an ordered list of integer sample counts in the range [1;M] at which to return 
        the running mean, standard deviation, and estimated error.
    'samples' is an array of uniform random samples to use. The length of samples should be N X M 
     where N is the number of fixing times and M is the number of paths.
    'integrator' controls how the samples are generated according to the following value list
        'standard', where the paths are generated by using the solution of the Black-Scholes SDE step-by-step
        'euler', to use Euler-method integration of the Black-Scholes SDE
        'milstein', to use Milstein-method integration of the Black-Scholes SDE
    """
    rate = pd.read_csv("Treasury Yield Data.csv", sep=',', header = None)
    rate_data = np.delete(rate.values, [0], axis = 1)
    
    date = np.delete(rate_data, np.s_[1:], 0)
    rateCurve = np.delete(rate_data, np.s_[0:-1], 0)
    
    date = np.ravel(np.array(date, dtype = np.float32))
    rateCurve = np.ravel(np.array(rateCurve, dtype = np.float32))
    
    r = 0.
    
    if np.any(date) == T:
        i = np.where(date == T)
        r = rateCurve[i]/100
    else:
        r = np.interp(T, date, rateCurve)/100
        
    M = 0
    np_checkpoints = np.array(checkpoints)
    if np.any(samples) == None:
        M = np_checkpoints[-1]
        
    else:
        M = np.shape(samples)[0]
    
    MonteCarlo = {}
    t = np.linspace(0.001,T,np.shape(samples)[1])
    dT = np.diff(np.append(np.array([0]), np.array(t)))
    z = randn(M,len(t))    
    running_means = []
    running_std = []
    running_sterr = []
    running_total = 0
    start = 0
    for i in range(len(np_checkpoints)):
        end = np_checkpoints[i]
        if integrator == 'standard':
            price_samples = S0*np.prod(exp((r-0.5*sigma**2)*dT + sigma*sqrt(dT)*z[start:end]), axis = 1)
            
        elif integrator == 'euler':
            price_samples = S0*np.prod(1.+(r)*dT + sigma*sqrt(dT)*z[start:end], axis=1)
            
        elif integrator == 'milstein':
            delStockCoeffdelAsset = sigma 
            price_samples = S0*np.prod(1.+(r)*dT + sigma*sqrt(dT)*z[start:end] +
                                          0.5*sigma*delStockCoeffdelAsset*(z[start:end]**2*dT-dT),axis=1)
            
        running_total = running_total + sum(price_samples)
        running_means.append(running_total/end)
        running_std.append(std(price_samples))
        running_sterr.append(std(price_samples)/sqrt(end - start))
        MonteCarlo['Means'] = running_means
        MonteCarlo['StdDevs'] = running_std
        MonteCarlo['StdErrs'] = running_sterr
        
        start = end
            
    vals=exp(-r*T) * maximum(0,price_samples-K)
    MonteCarlo['TV']=mean(vals)
    
    M1 = np.linspace(0, checkpoints[-1], 1000)
    z1 = randn(len(M1), len(t))
    running_means = []
    running_std = []
    running_sterr = []
    running_total = 0
    start = 0
    for i in range(len(np_checkpoints)):
        end = np_checkpoints[i]
        if integrator == 'standard':
            price_samples = S0*np.prod(exp((r-0.5*sigma**2)*dT + sigma*sqrt(dT)*z1[start:end]), axis = 1)
            
        elif integrator == 'euler':
            price_samples = S0*np.prod(1.+(r)*dT + sigma*sqrt(dT)*z1[start:end], axis=1)
            
        elif integrator == 'milstein':
            delStockCoeffdelAsset = sigma 
            price_samples = S0*np.prod(1.+(r)*dT + sigma*sqrt(dT)*z1[start:end] +
                                          0.5*sigma*delStockCoeffdelAsset*(z1[start:end]**2*dT-dT),axis=1)
        
        running_total = running_total + sum(price_samples)
        running_means.append(running_total/end)
        running_std.append(std(price_samples))
        running_sterr.append(std(price_samples)/sqrt(end - start))

    mean_vals=exp(-r*T) * maximum(0,price_samples-K)
    D=std(mean_vals)
    error_est=D/sqrt(M1)

    plt.figure(1)
    plt.plot(M1, mean_vals, 'r')
    plt.title('Price Vs Number of Sample')
    plt.xlabel('Number of Samples')
    plt.ylabel('Call Price')
    
    plt.figure(2)
    plt.plot(M1, error_est, 'b')
    plt.title('Standard Error in Call Price Vs Number of Sample')
    plt.xlabel('Number of Samples')
    plt.ylabel('Standard Error')
    
    return MonteCarlo

if __name__ == '__main__':
    
    checkpoints = [100, 200, 300, 400, 70000]
    samples = randn(70000, 1000)
    
    print(MCOptionPrices(95., 100., 1.0, 0., 0.25, 0., checkpoints, samples, 'standard'))

    